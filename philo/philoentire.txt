/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clean.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/02 10:00:36 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/12 12:02:44 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

void free_mem(t_table **table)
{
	if ((*table)->threads)
		free((*table)->threads);
	if ((*table)->philos)
		free((*table)->philos);
	if ((*table)->forks)
		free((*table)->forks);
    free(*table);
}

int destroy_philo_mutex(t_table **table)
{
	unsigned long long	i;

	i = 0;
	while (i < (*table)->numof_philo)
	{
		if (pthread_mutex_destroy(&(*table)->philos[i].philo_mutex) != 0)
				return (1);
		i++;
	}
	return (0);
}

/*MUST NOT destroy mutexes that are used by monitor while monitor thread is still going. need to wait for monitor first 
and then destroy mutexes*/
/*first join all threads, then destroy philo mutexes, lastly destroy global mutexes*/

int	join_destroy(t_table **table)
{
	unsigned long long	i;
		
	i = 0;
	while ((i < (*table)->numof_philo))
	{
		if (pthread_join((*table)->threads[i], NULL) != 0)
			return (1);
		i++;
	}
	if (pthread_join((*table)->monitor, NULL) != 0)
		return (1);
	i = 0;
	while (i < (*table)->numof_philo)
	{
		if (pthread_mutex_destroy(&(*table)->forks[i]) != 0)
			return (1);
		i++;
	}
	if (destroy_philo_mutex(table) != 0)
		return (1);
	if (pthread_mutex_destroy(&(*table)->end_mutex) != 0)
		return (1);
	if (pthread_mutex_destroy(&(*table)->print_mutex) != 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/01 13:33:19 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/11 16:37:59 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

/*im assigning left and right forks with ampersand because they are not a photocopy! it must be a pointer to the same mutex*/

int init_philos(t_table **table)
{
	unsigned long long	i;
	unsigned long long	quantity;

	quantity = (*table)->numof_philo;
	i = 0;
	while (i < quantity)
	{
		(*table)->philos[i].philo_id = i + 1;
		(*table)->philos[i].meals_eaten = 0;
		(*table)->philos[i].last_meal_time = convert_print_time();
		(*table)->philos[i].left_fork = &(*table)->forks[i];
		if (i == 0)
			(*table)->philos[i].right_fork = &(*table)->forks[quantity - 1];
		else
			(*table)->philos[i].right_fork = &(*table)->forks[i - 1];
		(*table)->philos[i].table = *table;
		if (pthread_mutex_init(&(*table)->philos[i].philo_mutex, NULL) != 0)
			return (1);
		i++;
	}
	return (0);
}

/*creating mutexes and threads*/
/*philos also malloced here, not locally anywhere else*/

int init_threads_mutexes(t_table **tbl)
{
	unsigned long long	i;
	
	i = 0;
	(*tbl)->philos = malloc(sizeof(t_philo) * ((*tbl)->numof_philo));
	(*tbl)->threads = malloc(sizeof(pthread_t) * ((*tbl)->numof_philo));
	(*tbl)->forks = malloc(sizeof(pthread_mutex_t) * ((*tbl)->numof_philo));
	if (!(*tbl)->philos || !(*tbl)->threads || !(*tbl)->forks)
		return (1);
	while (i < (*tbl)->numof_philo)
	{
		if (pthread_mutex_init(&(*tbl)->forks[i], NULL) != 0)
			return (1);
		i++;
	}
	if (pthread_mutex_init(&(*tbl)->end_mutex, NULL) != 0)
		return (1);
	if (pthread_mutex_init(&(*tbl)->print_mutex, NULL) != 0)
	 	return (1);
	if (init_philos(tbl))
        return (printf("Creating threads failed."), free_mem(tbl), 1);
	i = 0;
	while (i < (*tbl)->numof_philo)
	{
		if (pthread_create(&(*tbl)->threads[i], NULL, &rout, &(*tbl)->philos[i]))
			return (1);
		i++;
	}
	if (init_monitor_thread(tbl))
         return (printf("Monit thr. creation failed"), printf("tutaj: 2"), join_destroy(tbl), 1);
    return (0);
}

/*initialising also mutexes for ending flag and printing here*/

int init_monitor_thread(t_table **tbl)
{
	if (pthread_create(&(*tbl)->monitor, NULL, &monit_routine, *tbl) != 0)
		return (1);
	return (0);
}

int init_data(char **arguments, t_table **table)
{
    (*table)->numof_philo = ft_atoll(arguments[1]);
    (*table)->time_to_die = ft_atoll(arguments[2]);
    (*table)->time_to_eat = ft_atoll(arguments[3]);
    (*table)->time_to_sleep = ft_atoll(arguments[4]);
    if ((*table)->numof_philo == ULLONG_MAX
        || (*table)->time_to_die == ULLONG_MAX
        || (*table)->time_to_eat == ULLONG_MAX
        || (*table)->time_to_sleep == ULLONG_MAX)
        return (1);
    (*table)->meals_to_eat = 0; //default, if there is no arg[5]
    if (arguments[5])
    {
        (*table)->meals_to_eat = ft_atoll(arguments[5]);
        if ((*table)->meals_to_eat == ULLONG_MAX)
            return (1);
    }
	(*table)->full_philos = 0;
    (*table)->simulation_end = false;
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/01 13:02:09 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/11 18:30:17 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

//TO_DO   If convert_print_time can be without arguments?
//TO_DO   clear the functions to 25lines: main, init_threads_mutexes, monit_routine - NORMINETTE
//TO_DO   read about valgrind/helgrind in manual.
//TO_DO   put joining before freeing the table! otherwise threads can't join.
//TO_DO	  solve main to not return, just join thread and free table at the end.


/*important note - CAN'T init mutexes after threads creation, which in routine uses those mutexes! its data race*/
/*important note - if I define in struct pointer to mutex, I need to alocate memory for it and mutex_init.*/
/*if its only object wihtout pointer, it just need ampersand to pass the address of the object (and of course init too)*/

#include "philo.h"

/*check for arguments validity, compare with int max*/

int main(int argc, char **argv)
{
    t_table *table;

    if (argc < 5 || argc > 6)
        return (printf("Wrong input"), 1);
    table = malloc(sizeof(t_table));
    if (!table)
        return (1);
    if (init_data(argv, &table))
        return (printf("Invalid data"), free(table), 1);
    if (table->numof_philo > INT_MAX || table->time_to_die > INT_MAX
        || table->time_to_eat > INT_MAX || table->time_to_sleep > INT_MAX)
        return (printf("Wrong input"), free_mem(&table), 1);
    if (table->numof_philo == 0)
        return (printf("Must have at least one philosopher\n"), 1);
    if (argc == 6)
    {
		if (table->meals_to_eat > INT_MAX)
            return (printf("Wrong input"), free_mem(&table), 1);
	}
    if (init_threads_mutexes(&table))
        return (printf("Creating threads failed."), join_destroy(&table), 1); //tutaj zmienic zeby nie returnowal, usunac wiadomosci w sumie i tylko zodtaweic join tread bez returnowania
    // if (init_monitor_thread(&table))
    //     return (printf("Monit thr. creation failed"), printf("tutaj: 2"), join_destroy(&table), 1);
    if (join_destroy(&table))
		return (printf("Threads joining failed."), free_mem(&table), 1);
	free_mem(&table); //could be moved inside join_destroy. then I dont need ampersand and double pointer because its nothing to pass later on.
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   routine_functions.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/05 11:00:02 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/12 11:58:52 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

void philo_eating(t_philo *philo)
{
	if (philo->philo_id % 2 == 0)
	{
		pthread_mutex_lock(philo->left_fork);  //without ampersand - passing directly . not a pointer!!!
		print_status(philo->table, philo->philo_id, "picks up left fork");
		pthread_mutex_lock(philo->right_fork);
		print_status(philo->table, philo->philo_id, "picks up right fork");
	}
	else
	{
		pthread_mutex_lock(philo->right_fork);
		print_status(philo->table, philo->philo_id, "picks up right fork");
		pthread_mutex_lock(philo->left_fork);
		print_status(philo->table, philo->philo_id, "picks up left fork");
	}
	pthread_mutex_lock(&philo->philo_mutex);
	philo->last_meal_time = convert_print_time();
	philo->meals_eaten++;
	//pthread_mutex_unlock(&philo->philo_mutex);
	print_status(philo->table, philo->philo_id, "is eating");
	//pthread_mutex_lock(&philo->philo_mutex);
	if (philo->meals_eaten == philo->table->meals_to_eat)
	{
		pthread_mutex_lock(&philo->table->end_mutex);
		philo->table->full_philos++;
		pthread_mutex_unlock(&philo->table->end_mutex);
	}
	pthread_mutex_unlock(&philo->philo_mutex);
	custom_usleep(philo->table->time_to_eat);
	// if (philo->philo_id % 2 == 0)
	// {
	// 	pthread_mutex_unlock(philo->right_fork);
	// 	pthread_mutex_unlock(philo->left_fork);
	// }
	// else
	// {
	pthread_mutex_unlock(philo->left_fork);
	pthread_mutex_unlock(philo->right_fork);
	//}
	return ;
}

/*no need to mutex here, print_status has its own, I only usleep, I dont access shared changeable data*/
void philo_sleeping(t_philo *philo)
{
	print_status(philo->table, philo->philo_id, "is sleeping");
	custom_usleep(philo->table->time_to_sleep);
	return ;
}

void philo_thinking(t_philo *philo)
{
	print_status(philo->table, philo->philo_id, "is thinking");
	return ;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   routines.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/04 14:38:27 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/12 12:02:34 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

void *rout(void *argument)
{
	t_philo 			*philo;

	philo = (t_philo *)argument;
	if (philo->philo_id % 2)
		usleep(50);
	while (is_simulation_going(philo->table))
	{	
		philo_eating(philo);
		philo_sleeping(philo);
		philo_thinking(philo);
	}
	return (NULL);
}

/* this function constantly checking if the philo died.*/
void	*monit_routine(void *argument)
{
	t_table 			*table;
	unsigned long long	i;
	unsigned long long	current_time;

	i = 0;
	current_time = 0;
	table = (t_table *)argument;
	while (1)
	{
		i = 0;
		while (i < table->numof_philo)
		{
			pthread_mutex_lock(&table->philos[i].philo_mutex);
			if ((convert_print_time() - table->philos[i].last_meal_time) > table->time_to_die)
			{
				print_status(table, table->philos[i].philo_id, "died");  //i changed it to here instead of being after table->simu = 1
				pthread_mutex_lock(&table->end_mutex);
				table->simulation_end = 1;
				pthread_mutex_unlock(&table->end_mutex);
				pthread_mutex_unlock(&table->philos[i].philo_mutex);
				return (NULL);
			}
			pthread_mutex_unlock(&table->philos[i].philo_mutex);
			i++;
		}
		pthread_mutex_lock(&table->end_mutex);
		if (table->full_philos == table->numof_philo)
			table->simulation_end = true;
		pthread_mutex_unlock(&table->end_mutex);
		if (!is_simulation_going(table))
			break;
		usleep(50); //little busy-wait to relax CPU/
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/01 15:33:12 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/12 12:01:48 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "philo.h"

/*usleep doesnt need mutex bc it operates on read-only data and doesnt change any shared data
print DOES need mutex because it not only reads but writes to stdout also, stdout is shared
mutex is to be performed inside print_status. not around print_status in calling function!!
important to check if the simulation is going because there shouldn't be "sleeping" msg after death*/

void custom_usleep(unsigned long long time)
{
	unsigned long long	start_time;

	start_time = convert_print_time();
	while (convert_print_time() - start_time < time)
	{
		usleep(100);
	}
}

void print_status(t_table *tbl, int philo_id, char *msg)
{
	struct timeval t;

	pthread_mutex_lock(&tbl->print_mutex);
	if (is_simulation_going(tbl))
	{
		gettimeofday(&t, NULL);
		pthread_mutex_lock(&tbl->end_mutex);
		printf("%ld %d %s\n",
				t.tv_sec*1000 + t.tv_usec/1000, philo_id, msg);
		pthread_mutex_unlock(&tbl->end_mutex);
	}
	pthread_mutex_unlock(&tbl->print_mutex);
}

int is_simulation_going(t_table *table)
{
	pthread_mutex_lock(&table->end_mutex);
	if (table->simulation_end)
	{
		pthread_mutex_unlock(&table->end_mutex);
		return (0);
	}
	else
	{
		pthread_mutex_unlock(&table->end_mutex);
		return (1);
	}
}

/*timeval struct consists of tv_sec in seconds and microseconds.
decided to conver to miliseconds.*/
unsigned long long convert_print_time()
{
	struct timeval	time;

	if (gettimeofday(&time, NULL) != 0)
	{
		printf("Time counter failed");
		return (0);
	}
	return ((time.tv_sec * 1000) + (time.tv_usec / 1000));
}


/* Type ull to prevent overflowing in parseing.*/
unsigned long long ft_atoll(char *str)
{
    int                 i;
    unsigned long long  number;

    i = 0;
    number = 0;
    while (str[i] == ' ' || str[i] == '\n' || str[i] == '\t')
        i++;
    if (str[i] == '+')
        i++;
    if (str[i] == '\0')
        return (ULLONG_MAX);
    while (str[i] && str[i] >= '0' && str[i] <= '9')
    {
        number = number * 10 + (str[i] - 48);
        i++;
    }
    if (str[i] != '\0')
        return (ULLONG_MAX);
    return (number);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   philo.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: hgatarek <hgatarek@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/01 10:54:29 by hgatarek          #+#    #+#             */
/*   Updated: 2025/09/11 18:21:14 by hgatarek         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef PHILO_H
# define PHILO_H

#include <sys/syscall.h>
#include <unistd.h>
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <limits.h>
#include <stdbool.h>

//typedef alias vs struct tag name*

/*forward declaration because of circular structures' dependencies*/
struct s_philo;
typedef struct s_table
{
    unsigned long long  numof_philo;
    unsigned long long  time_to_die;
    unsigned long long  time_to_eat;
    unsigned long long  time_to_sleep;
    unsigned long long  meals_to_eat;
	unsigned long long	full_philos;
	bool                simulation_end;
	pthread_t           *threads;
	pthread_t			monitor;
    pthread_mutex_t     *forks;
	pthread_mutex_t		end_mutex;
	pthread_mutex_t		print_mutex;
    struct s_philo      *philos;
}   t_table;

typedef struct s_philo
{
    int					philo_id;
	unsigned long long	meals_eaten;
	t_table				*table;
    pthread_mutex_t		*left_fork;
    pthread_mutex_t		*right_fork;
	pthread_mutex_t		philo_mutex;
    unsigned long long	last_meal_time;
}   t_philo;

/*init.c*/
int					init_philos(t_table **table);
int					init_threads_mutexes(t_table **tbl);
int					init_monitor_thread(t_table **tbl);
int					init_data(char **arguments, t_table **table);

/*routines.c*/
void				*rout(void *argument);
void				*monit_routine(void *argument);

/*routines_functions.c*/
void				philo_eating(t_philo *philo);
void				philo_sleeping(t_philo *philo);
void				philo_thinking(t_philo *philo);

/*clean.c*/
void				free_mem(t_table **table);
int					destroy_philo_mutex(t_table **table);
int					join_destroy(t_table **table);

/*utils.c*/
void 				print_status(t_table *tbl, int philo_id, char *msg);
int 				is_simulation_going(t_table *table);
unsigned long long	convert_print_time();
unsigned long long	ft_atoll(char *str);
void				custom_usleep(unsigned long long time);
#endif